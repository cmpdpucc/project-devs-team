#!/usr/bin/env python3
"""
Skill: vulnerability-scanner
Script: security_scan.py
Purpose: Validate that security principles from SKILL.md are applied correctly
Usage: python security_scan.py <project_path> [--scan-type all|deps|secrets|patterns|config]
Output: JSON with validation findings

This script verifies:
1. Dependencies - Supply chain security (OWASP A03)
2. Secrets - No hardcoded credentials (OWASP A04)
3. Code Patterns - Dangerous patterns identified (OWASP A05)
4. Configuration - Security settings validated (OWASP A02)
"""
import subprocess
import json
import os
import sys
import re
import argparse
from pathlib import Path
from typing import Dict, List, Any
from datetime import datetime

# Fix Windows console encoding for Unicode output
try:
    sys.stdout.reconfigure(encoding='utf-8', errors='replace')
    sys.stderr.reconfigure(encoding='utf-8', errors='replace')
except AttributeError:
    pass  # Python < 3.7


# ============================================================================
#  CONFIGURATION
# ============================================================================

SECRET_PATTERNS = [
    # API Keys & Tokens
    (r'api[_-]?key\s*[=:]\s*["\'][^"\']{10,}["\']', "API Key", "high"),
    (r'token\s*[=:]\s*["\'][^"\']{10,}["\']', "Token", "high"),
    (r'bearer\s+[a-zA-Z0-9\-_.]+', "Bearer Token", "critical"),
    
    # Cloud Credentials
    (r'AKIA[0-9A-Z]{16}', "AWS Access Key", "critical"),
    (r'aws[_-]?secret[_-]?access[_-]?key\s*[=:]\s*["\'][^"\']+["\']', "AWS Secret", "critical"),
    (r'AZURE[_-]?[A-Z_]+\s*[=:]\s*["\'][^"\']+["\']', "Azure Credential", "critical"),
    (r'GOOGLE[_-]?[A-Z_]+\s*[=:]\s*["\'][^"\']+["\']', "GCP Credential", "critical"),
    
    # Database & Connections
    (r'password\s*[=:]\s*["\'][^"\']{4,}["\']', "Password", "high"),
    (r'(mongodb|postgres|mysql|redis):\/\/[^\s"\']+', "Database Connection String", "critical"),
    
    # Private Keys
    (r'-----BEGIN\s+(RSA|PRIVATE|EC)\s+KEY-----', "Private Key", "critical"),
    (r'ssh-rsa\s+[A-Za-z0-9+/]+', "SSH Key", "critical"),
    
    # JWT
    (r'eyJ[A-Za-z0-9-_]+\.eyJ[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+', "JWT Token", "high"),
]

DANGEROUS_PATTERNS = [
    # Injection risks
    (r'eval\s*\(', "eval() usage", "critical", "Code Injection risk"),
    (r'exec\s*\(', "exec() usage", "critical", "Code Injection risk"),
    (r'new\s+Function\s*\(', "Function constructor", "high", "Code Injection risk"),
    (r'child_process\.exec\s*\(', "child_process.exec", "high", "Command Injection risk"),
    (r'subprocess\.call\s*\([^)]*shell\s*=\s*True', "subprocess with shell=True", "high", "Command Injection risk"),
    
    # XSS risks
    (r'dangerouslySetInnerHTML', "dangerouslySetInnerHTML", "high", "XSS risk"),
    (r'\.innerHTML\s*=', "innerHTML assignment", "medium", "XSS risk"),
    (r'document\.write\s*\(', "document.write", "medium", "XSS risk"),
    
    # SQL Injection indicators
    (r'["\'][^"\']*\+\s*[a-zA-Z_]+\s*\+\s*["\'].*(?:SELECT|INSERT|UPDATE|DELETE)', "SQL String Concat", "critical", "SQL Injection risk"),
    (r'f"[^"]*(?:SELECT|INSERT|UPDATE|DELETE)[^"]*\{', "SQL f-string", "critical", "SQL Injection risk"),
    
    # Insecure configurations
    (r'verify\s*=\s*False', "SSL Verify Disabled", "high", "MITM risk"),
    (r'--insecure', "Insecure flag", "medium", "Security disabled"),
    (r'disable[_-]?ssl', "SSL Disabled", "high", "MITM risk"),
    
    # Unsafe deserialization
    (r'pickle\.loads?\s*\(', "pickle usage", "high", "Deserialization risk"),
    (r'yaml\.load\s*\([^)]*\)(?!\s*,\s*Loader)', "Unsafe YAML load", "high", "Deserialization risk"),
]

SKIP_DIRS = {'node_modules', '.git', 'dist', 'build', '__pycache__', '.venv', 'venv', '.next'}
CODE_EXTENSIONS = {'.js', '.ts', '.jsx', '.tsx', '.py', '.go', '.java', '.rb', '.php'}
CONFIG_EXTENSIONS = {'.json', '.yaml', '.yml', '.toml', '.env', '.env.local', '.env.development'}


# ============================================================================
#  SCANNING FUNCTIONS
# ============================================================================

def scan_dependencies(project_path: str) -> Dict[str, Any]:
    """
    Validate supply chain security (OWASP A03).
    Checks: npm audit, lock file presence, dependency age.
    """
    results = {"tool": "dependency_scanner", "findings": [], "status": "[OK] Secure"}
    
    # Check for lock files
    lock_files = {
        "npm": ["package-lock.json", "npm-shrinkwrap.json"],
        "yarn": ["yarn.lock"],
        "pnpm": ["pnpm-lock.yaml"],
        "pip": ["requirements.txt", "Pipfile.lock", "poetry.lock"],
    }
    
    found_locks = []
    missing_locks = []
    
    for manager, files in lock_files.items():
        pkg_file = "package.json" if manager in ["npm", "yarn", "pnpm"] else "setup.py"
        pkg_path = Path(project_path) / pkg_file
        
        if pkg_path.exists() or (manager == "pip" and (Path(project_path) / "requirements.txt").exists()):
            has_lock = any((Path(project_path) / f).exists() for f in files)
            if has_lock:
                found_locks.append(manager)
            else:
                missing_locks.append(manager)
                results["findings"].append({
                    "type": "Missing Lock File",
                    "severity": "high",
                    "message": f"{manager}: No lock file found. Supply chain integrity at risk."
                })
    
    # Run npm audit if applicable
    if (Path(project_path) / "package.json").exists():
        try:
            result = subprocess.run(
                ["npm", "audit", "--json"],
                cwd=project_path,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            try:
                audit_data = json.loads(result.stdout)
                vulnerabilities = audit_data.get("vulnerabilities", {})
                
                severity_count = {"critical": 0, "high": 0, "moderate": 0, "low": 0}
                for vuln in vulnerabilities.values():
                    sev = vuln.get("severity", "low").lower()
                    if sev in severity_count:
                        severity_count[sev] += 1
                
                if severity_count["critical"] > 0:
                    results["status"] = "[!!] Critical vulnerabilities"
                    results["findings"].append({
                        "type": "npm audit",
                        "severity": "critical",
                        "message": f"{severity_count['critical']} critical vulnerabilities in dependencies"
                    })
                elif severity_count["high"] > 0:
                    results["status"] = "[!] High vulnerabilities"
                    results["findings"].append({
                        "type": "npm audit",
                        "severity": "high",
                        "message": f"{severity_count['high']} high severity vulnerabilities"
                    })
                
                results["npm_audit"] = severity_count
                
            except json.JSONDecodeError:
                pass
                
        except (FileNotFoundError, subprocess.TimeoutExpired):
            pass
    
    if not results["findings"]:
        results["status"] = "[OK] Supply chain checks passed"
    
    return results


# ============================================================================
#  UNIFIED SCANNING
# ============================================================================

def scan_file_content(filepath: Path, project_path: str, checks: List[str]) -> Dict[str, List[Dict]]:
    """
    Analyze a single file for multiple types of issues to minimize I/O.
    """
    findings = {
        "secrets": [],
        "patterns": [],
        "config": []
    }
    
    try:
        # Read file once
        with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
            lines = content.splitlines()

        rel_path = str(filepath.relative_to(project_path))
        ext = filepath.suffix.lower()

        # 1. Secret Scanning (All text files)
        if "secrets" in checks and (ext in CODE_EXTENSIONS or ext in CONFIG_EXTENSIONS):
            for pattern, secret_type, severity in SECRET_PATTERNS:
                matches = re.findall(pattern, content, re.IGNORECASE)
                if matches:
                    findings["secrets"].append({
                        "file": rel_path,
                        "type": secret_type,
                        "severity": severity,
                        "count": len(matches)
                    })

        # 2. Code Patterns (Code files only)
        if "patterns" in checks and ext in CODE_EXTENSIONS:
            for line_num, line in enumerate(lines, 1):
                for pattern, name, severity, category in DANGEROUS_PATTERNS:
                    if re.search(pattern, line, re.IGNORECASE):
                        findings["patterns"].append({
                            "file": rel_path,
                            "line": line_num,
                            "pattern": name,
                            "severity": severity,
                            "category": category,
                            "snippet": line.strip()[:80]
                        })

        # 3. Configuration (Config files only)
        if "config" in checks and (ext in CONFIG_EXTENSIONS or filepath.name in ['next.config.js', 'webpack.config.js', '.eslintrc.js']):
            # Common config issues
            config_issues = [
                (r'"DEBUG"\s*:\s*true', "Debug mode enabled", "high"),
                (r'debug\s*=\s*True', "Debug mode enabled", "high"),
                (r'NODE_ENV.*development', "Development mode in config", "medium"),
                (r'"CORS_ALLOW_ALL".*true', "CORS allow all origins", "high"),
                (r'"Access-Control-Allow-Origin".*\*', "CORS wildcard", "high"),
                (r'allowCredentials.*true.*origin.*\*', "Dangerous CORS combo", "critical"),
            ]
            
            for pattern, issue, severity in config_issues:
                if re.search(pattern, content, re.IGNORECASE):
                    findings["config"].append({
                        "file": rel_path,
                        "issue": issue,
                        "severity": severity
                    })

    except Exception:
        pass

    return findings

def run_unified_scan(project_path: str, scan_types: List[str]) -> Dict[str, Any]:
    """
    Perform a single-pass scan of the file system.
    """
    results = {
        "secrets": {"tool": "secret_scanner", "findings": [], "status": "[OK]", "scanned_files": 0, "by_severity": {"critical": 0, "high": 0, "medium": 0}},
        "patterns": {"tool": "pattern_scanner", "findings": [], "status": "[OK]", "scanned_files": 0, "by_category": {}},
        "config": {"tool": "config_scanner", "findings": [], "status": "[OK]", "checks": {}}
    }

    # Configuration Header Check (Single pass, specific files)
    if "config" in scan_types:
        header_files = ["next.config.js", "next.config.mjs", "middleware.ts", "nginx.conf"]
        for hf in header_files:
            if (Path(project_path) / hf).exists():
                results["config"]["checks"]["security_headers_config"] = True
                break
        else:
            results["config"]["checks"]["security_headers_config"] = False
            results["config"]["findings"].append({
                "issue": "No security headers configuration found",
                "severity": "medium",
                "recommendation": "Configure CSP, HSTS, X-Frame-Options headers"
            })

    # Main O(N) Walk
    for root, dirs, files in os.walk(project_path):
        dirs[:] = [d for d in dirs if d not in SKIP_DIRS]
        
        for file in files:
            filepath = Path(root) / file
            ext = filepath.suffix.lower()
            
            # Optimization: Skip likely binary/irrelevant files early
            if ext not in CODE_EXTENSIONS and ext not in CONFIG_EXTENSIONS and file not in ['next.config.js', 'webpack.config.js', '.eslintrc.js']:
                continue

            file_findings = scan_file_content(filepath, project_path, scan_types)
            
            # Aggregate Results
            if "secrets" in scan_types:
                results["secrets"]["scanned_files"] += 1
                if file_findings["secrets"]:
                    results["secrets"]["findings"].extend(file_findings["secrets"])
                    for f in file_findings["secrets"]:
                        results["secrets"]["by_severity"][f["severity"]] += 1

            if "patterns" in scan_types and ext in CODE_EXTENSIONS:
                results["patterns"]["scanned_files"] += 1
                if file_findings["patterns"]:
                    results["patterns"]["findings"].extend(file_findings["patterns"])
                    for f in file_findings["patterns"]:
                         results["patterns"]["by_category"][f["category"]] = results["patterns"]["by_category"].get(f["category"], 0) + 1

            if "config" in scan_types and (ext in CONFIG_EXTENSIONS or file in ['next.config.js', 'webpack.config.js', '.eslintrc.js']):
                if file_findings["config"]:
                    results["config"]["findings"].extend(file_findings["config"])

    # Post-process statuses
    # Secrets Status
    if results["secrets"]["by_severity"]["critical"] > 0:
        results["secrets"]["status"] = "[!!] CRITICAL: Secrets exposed!"
    elif results["secrets"]["by_severity"]["high"] > 0:
        results["secrets"]["status"] = "[!] HIGH: Secrets found"
    elif results["secrets"]["findings"]:
         results["secrets"]["status"] = "[?] Potential secrets detected"
    results["secrets"]["findings"] = results["secrets"]["findings"][:15]

    # Patterns Status
    crit_p = sum(1 for f in results["patterns"]["findings"] if f["severity"] == "critical")
    high_p = sum(1 for f in results["patterns"]["findings"] if f["severity"] == "high")
    if crit_p > 0:
        results["patterns"]["status"] = f"[!!] CRITICAL: {crit_p} dangerous patterns"
    elif high_p > 0:
        results["patterns"]["status"] = f"[!] HIGH: {high_p} risky patterns"
    elif results["patterns"]["findings"]:
         results["patterns"]["status"] = "[?] Some patterns need review"
    results["patterns"]["findings"] = results["patterns"]["findings"][:20]

    # Config Status
    if any(f["severity"] == "critical" for f in results["config"]["findings"]):
        results["config"]["status"] = "[!!] CRITICAL: Configuration issues"
    elif any(f["severity"] == "high" for f in results["config"]["findings"]):
        results["config"]["status"] = "[!] HIGH: Configuration review needed"
    elif results["config"]["findings"]:
        results["config"]["status"] = "[?] Minor configuration issues"

    return results

# ============================================================================
#  MAIN
# ============================================================================

def run_full_scan(project_path: str, scan_type: str = "all") -> Dict[str, Any]:
    """Execute security validation scans."""
    
    report = {
        "project": project_path,
        "timestamp": datetime.now().isoformat(),
        "scan_type": scan_type,
        "scans": {},
        "summary": {
            "total_findings": 0,
            "critical": 0,
            "high": 0,
            "overall_status": "[OK] SECURE"
        }
    }

    # 1. Dependency Scan (Independent)
    if scan_type == "all" or scan_type == "deps":
        report["scans"]["dependencies"] = scan_dependencies(project_path)

    # 2. Content Scans (Unified)
    active_types = []
    if scan_type == "all":
        active_types = ["secrets", "patterns", "config"]
    else:
        if scan_type in ["secrets", "patterns", "config"]:
            active_types = [scan_type]
    
    if active_types:
        unified_results = run_unified_scan(project_path, active_types)
        report["scans"].update(unified_results)
    
    # Summary Aggregation
    for scan in report["scans"].values():
        findings_count = len(scan.get("findings", []))
        report["summary"]["total_findings"] += findings_count
        
        for finding in scan.get("findings", []):
            sev = finding.get("severity", "low")
            if sev == "critical":
                report["summary"]["critical"] += 1
            elif sev == "high":
                report["summary"]["high"] += 1
    
    # Determine overall status
    if report["summary"]["critical"] > 0:
        report["summary"]["overall_status"] = "[!!] CRITICAL ISSUES FOUND"
    elif report["summary"]["high"] > 0:
        report["summary"]["overall_status"] = "[!] HIGH RISK ISSUES"
    elif report["summary"]["total_findings"] > 0:
        report["summary"]["overall_status"] = "[?] REVIEW RECOMMENDED"
    
    return report


def main():
    parser = argparse.ArgumentParser(
        description="Validate security principles from vulnerability-scanner skill"
    )
    parser.add_argument("project_path", nargs="?", default=".", help="Project directory to scan")
    parser.add_argument("--scan-type", choices=["all", "deps", "secrets", "patterns", "config"],
                        default="all", help="Type of scan to run")
    parser.add_argument("--output", choices=["json", "summary"], default="json",
                        help="Output format")
    
    args = parser.parse_args()
    
    if not os.path.isdir(args.project_path):
        print(json.dumps({"error": f"Directory not found: {args.project_path}"}))
        sys.exit(1)
    
    result = run_full_scan(args.project_path, args.scan_type)
    
    if args.output == "summary":
        print(f"\n{'='*60}")
        print(f"Security Scan: {result['project']}")
        print(f"{'='*60}")
        print(f"Status: {result['summary']['overall_status']}")
        print(f"Total Findings: {result['summary']['total_findings']}")
        print(f"  Critical: {result['summary']['critical']}")
        print(f"  High: {result['summary']['high']}")
        print(f"{'='*60}\n")
        
        for scan_name, scan_result in result['scans'].items():
            print(f"\n{scan_name.upper()}: {scan_result.get('status', 'Unknown')}")
            for finding in scan_result.get('findings', [])[:5]:
                # Format check
                if isinstance(finding, dict):
                    msg = finding.get('message') or finding.get('issue') or finding.get('type')
                    print(f"  - {msg}")
                else:
                    print(f"  - {finding}")
    else:
        print(json.dumps(result, indent=2))


if __name__ == "__main__":
    main()
