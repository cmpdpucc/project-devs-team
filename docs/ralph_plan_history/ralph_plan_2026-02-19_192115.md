# üöÄ RALPH PLAN ‚Äî Self-Enhancement v2: Memory & Resilience

> **Questo file √® il SINGOLO punto di verit√† per TUTTE le operazioni in corso.**
> Prima di ogni risposta, Antigravity DEVE leggere questo file.
> **Questo file traccia l'avanzamento. Segna i task come completati `[x]` quando la DoD √® soddisfatta.**

---

## LEGACY ‚Äî Fasi Completate

<details>
<summary>‚úÖ Click per espandere le fasi legacy gi√† completate</summary>

### Strict Supervision Refactor
> **üéØ Supervisore:** `@backend-specialist` (skills: `api-patterns`, `nodejs-best-practices`)

- [x] Implementare `ProcessManager` con singleton thread-safe
- [x] Rimuovere `detach()` - Strict Supervision
- [x] Aggiungere `wait()` blocking al `ProcessManager`
- [x] Creare workflow `supervised-run.md`
- [x] Aggiornare `ralph-loop.md` con protocollo supervisione

### Self-Governance Framework v1
> **üéØ Supervisore:** `@orchestrator` (skills: `parallel-agents`, `behavioral-modes`)

- [x] Creare `ralph_plan.md`
- [x] Creare regola `self-governance.md` con lifecycle rotation
- [x] Implementare kill-switch verification
- [x] Creare regola `task-tracking.md`
- [x] Aggiungere Step 0 (Plan Lifecycle) a `ralph-loop.md`
- [x] Creare directory archivio `docs/ralph_plan_history/`

</details>

---

## Phase 1 ‚Äî üß† Unified Memory System (Persistent + Context Guardian)
> **üéØ Supervisore:** `@orchestrator` (skills: `parallel-agents`, `behavioral-modes`)
> **Obiettivo:** Creare un sistema di memoria unificato in `.agent/memory/` che persiste tra sessioni e preserva contesto dentro le sessioni. Formato: Markdown strutturato con YAML frontmatter (pi√π efficiente per me).

### 1.1 Memory Infrastructure
- [x] Creare directory `.agent/memory/`
  - **Agente:** `@devops-engineer` | Skills: `deployment-procedures`
  - DoD: Directory esiste con struttura corretta

### 1.2 PROJECT_CONTEXT.md
- [x] Creare `.agent/memory/PROJECT_CONTEXT.md` ‚Äî Mappa del progetto (tech stack, patterns, file critici)
  - **Agente:** `@project-planner` | Skills: `architecture`, `plan-writing`
  - DoD: File contiene: cos'√® il progetto, tech stack, architectural patterns, file critici. YAML frontmatter con `last_updated`.

### 1.3 LESSONS_LEARNED.md
- [x] Creare `.agent/memory/LESSONS_LEARNED.md` ‚Äî Database errori con Date ‚Üí Error ‚Üí Fix ‚Üí Lesson
  - **Agente:** `@project-planner` | Skills: `plan-writing`
  - DoD: File contiene almeno 5 lezioni dalla sessione corrente. Max 50 entries, poi prune oldest.

### 1.4 USER_PREFERENCES.md
- [x] Creare `.agent/memory/USER_PREFERENCES.md` ‚Äî Come l'utente preferisce lavorare
  - **Agente:** `@project-planner` | Skills: `brainstorming`
  - DoD: File contiene: lingua preferita, stile di comunicazione, priorit√†, pattern di lavoro osservati.

### 1.5 SESSION_LOG.md
- [x] Creare `.agent/memory/SESSION_LOG.md` ‚Äî Checkpoint della sessione corrente (scritto ogni ~10 tool calls)
  - **Agente:** `@orchestrator` | Skills: `behavioral-modes`
  - DoD: Template con: decisions made, files modified, current focus, open questions. YAML con `session_start` e `last_checkpoint`.

### 1.6 DECISIONS.md
- [x] Creare `.agent/memory/DECISIONS.md` ‚Äî Architecture Decision Records automatici
  - **Agente:** `@project-planner` | Skills: `architecture`, `plan-writing`
  - DoD: File con ADR format leggero. Almeno 3 decisioni dalla sessione corrente.

### 1.7 Memory Loader Rule
- [x] Creare `.agent/rules/memory-loader.md` ‚Äî Regola che impone la lettura della memoria all'inizio di ogni sessione
  - **Agente:** `@orchestrator` | Skills: `behavioral-modes`, `plan-writing`
  - DoD: Regola specifica: (1) leggi PROJECT_CONTEXT, (2) leggi LESSONS_LEARNED, (3) leggi USER_PREFERENCES, (4) se esiste SESSION_LOG recupera contesto. Trigger: `session_start`, priority: `highest`.

### 1.8 Session Checkpoint Rule
- [x] Aggiornare `.agent/rules/self-governance.md` con checkpoint periodico
  - **Agente:** `@orchestrator` | Skills: `behavioral-modes`
  - DoD: Regola include: "Ogni ~10 tool calls, aggiorna SESSION_LOG.md". Sezione dedicata.

### 1.9 Update GEMINI.md Reference
- [x] Aggiornare `.agent/rules/GEMINI.md` ‚Äî Cambiare path memoria da `.antigravity/memory/` a `.agent/memory/`
  - **Agente:** `@devops-engineer` | Skills: `deployment-procedures`
  - DoD: Path corretto, nessun riferimento stale.

---

## Phase 2 ‚Äî üîÑ Auto-Recovery & Error Resilience
> **üéØ Supervisore:** `@debugger` (skills: `systematic-debugging`)
> **Obiettivo:** Quando un comando fallisce, classificare automaticamente l'errore, tentare un fix (max 3 tentativi), e salvare il pattern in memoria per il futuro.

### 2.1 Error Recovery Rule
- [x] Creare `.agent/rules/error-recovery.md` ‚Äî Protocollo di recovery automatico
  - **Agente:** `@debugger` | Skills: `systematic-debugging`
  - DoD: Regola con tabella classificazione errori (10+ pattern), strategia auto-fix per tipo, max 3 retry, escalation protocol. Sezione "NEVER auto-recover" per errori pericolosi.

### 2.2 Error Patterns Knowledge Base
- [x] Creare `.agent/memory/ERROR_PATTERNS.md` ‚Äî Database vivente di pattern/errori incontrati e risolti
  - **Agente:** `@debugger` | Skills: `systematic-debugging`
  - DoD: File con almeno 3 pattern dalla sessione corrente. Formato: Pattern ‚Üí Trigger ‚Üí Root Cause ‚Üí Fix ‚Üí Occurrences.

### 2.3 Update Task Tracking
- [x] Estendere `.agent/rules/task-tracking.md` con sezione recovery
  - **Agente:** `@orchestrator` | Skills: `behavioral-modes`
  - DoD: Anti-pattern include: "Mai ignorare exit code != 0 senza classificare", "Mai riprovare >3 volte senza escalation".

### 2.4 Recovery Verification Test
- [x] Test pratico: eseguire un comando che fallir√† intenzionalmente e verificare che il protocollo recovery si attiva
  - **Agente:** `@test-engineer` | Skills: `testing-patterns`
  - DoD: Comando fallito ‚Üí errore classificato ‚Üí fix tentato ‚Üí risultato loggato in LESSONS_LEARNED.

---

## üõ°Ô∏è Processi Attivi (Kill Switch Registry)

| PID | Tipo | Porta | Stato | Lanciato Da |
|-----|------|-------|-------|-------------|
| - | - | - | Nessun processo attivo | - |

---

## üìù Log Decisioni

| Timestamp | Decisione | Motivazione |
|-----------|-----------|-------------|
| 2026-02-16 04:35 | Merge Memory + Context Guardian | Sono lo stesso problema a timescale diverse |
| 2026-02-16 04:35 | Formato .md con YAML frontmatter | Pi√π efficiente per me: native tools, grep-able, small files |
| 2026-02-16 04:35 | Error classification table | Pattern matching su stderr √® il modo pi√π veloce per auto-diagnosi |

---

## üî¥ Lezioni Apprese

1. **MAI dichiarare un processo terminato senza verificare il PID**
2. **MAI dimenticare il piano** ‚Üí Leggere `ralph_plan.md` ad OGNI risposta
3. **Archiviare SEMPRE il piano completato** ‚Üí `docs/ralph_plan_history/`
4. **Dopo multi-line edit, SEMPRE view full file** ‚Üí Evita NameError da codice troncato
5. **Persistent Memory + Context Guardian = stesso problema** ‚Üí Un solo sistema unificato
